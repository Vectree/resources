# Прерывания

Перывания представляют собой некоторый запрос, который нужно срочно обработать. Для этого выполнение основной программы останавливается и вызывается код прерывания (обработчик прерывания), после выполнения которого, управление возвращается к основной программе. Соответственно, чтобы надолго не задерживать выполнение основной программы, выполнение кода обработчика должно занимать мало времени.

В ARM процессорах управлением прерываний занимается Nested vectored interrupt controller (NVIC). Он позволяет назначать приоритет прерываниям. И в случае если во время выполнения прерывания случиться более приоритетное прерывание, то выполнения текущего порывания будет остановлено, и начнет выполняться более приоритетное (рисунок 1).

![Alt text](https://pp.userapi.com/c841228/v841228422/62fb3/mkf_RpIzP7s.jpg)

Рисунок 1. Временная диаграмма прерываний

Перывания могут генерировать программно, таймерами, модулями DMA, и т.д. В данной работе нас будет интересовать работа с внешними
прерываниями, которые вызываемых изменением входного сигнала на пинах.
 
В котроллерах STM32 имеется 16 линий внешних прерываний, которые подключены к пинам как показано на рисунке 2.

![Alt text](https://pp.userapi.com/c841228/v841228422/62fbd/n4l7eLvnTYs.jpg)

Рисунок 2. Линии внешних прерываний

Как видно из рисунка, любой пин может быть настроен на работу с
перываниями, однако нельзя одновременно задействовать пины с одним и тем же номером. Так, например, нельзя одновременно настроить на работу с прерываниями пины PA0 и PC0, но PA0 и PC1 можно.

Замечание: в дальнейшем обозначение пином будет иметь следущий формат `P<номер_порта><номер_пина>`, где `<номер_порта>` - A, B, C, D, E или F, а `<номер_пина>` число от 0 до 15.

В зависимости от настройки, пины могут вызвать перывания при следящих изменениях входного сигнала:
1) изменения входного сигнала с 0 на 1 (**GPIO_MODE_IT_RISING**) 32;
2) изменение входного сигнала с 1 на 0 (**GPIO_MODE_IT_FALLING_EDGE**);
3) оба предыдущих случая (**GPIO_MODE_IT_RISING_FALLING**).

Теперь перейдем непосредственно способу обработки порываний. Все
обработчики прерываний представляют из себя обычные C функции, которые ничего не принимают на вход и ничего не возвращают: `void some_irq_handler(void)`. Ссылки на эти функции находятся в массиве, называемом вектором прерываний. В созданных ранее проектах, вы можете найти вектор прерываний в файле startup_stm32f303xc.s (рисунок 3)

![Alt text](https://pp.userapi.com/c841228/v841228422/62fc7/BB1Pu7Mi-tU.jpg)

Рисунок 3. Вектор прерываний

В данном векторе можно заметить, что для обработки внешний прерываний
имеются следующие обработчики: 
* EXTI0_IRQHandler,
* EXTI1_IRQHandler,
* EXTI2_TSC_IRQHandler,
* EXTI3_IRQHandler,
* EXTI4_IRQHandler,
* EXTI9_5_IRQHandler,
* EXTI15_10_IRQHandler.

Как видно, у нас имеется 7 обработчиков перываний на 16 линий. В данном
случае один обработчик EXTI9_5_IRQHandler обрабатывает все прерывания от линий 5-9, а EXTI15_10_IRQHandler от 10-15. Поэтому при их использовании, так же надо будет определить какая линия вызвала перывание. Как это сделано, будет сказано показано позже.

## Задание

* Шаг #1: Пример программы для работы с прерываниями
* Шаг #2: Использования С++ в keil uVision 5

> **Warning**: Все перечисленные шаги находятся во вкладке **Issues**!

## Авторы
Задание взято с лабораторного практикума по изучению ARM микроконтроллеров серии STM32

Бабанов К.В., Ключарев А.А., Кочин К.А.

Спб ГУАП 2017
