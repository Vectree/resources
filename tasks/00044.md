# Граббер
Открываем любимый редактор создаем новый проект. Изначально код пустой программы выглядит примерно так:
```go
package main
 
import (
    "fmt"
)
 
func main() {
    fmt.Println("Hello World!")
}
``` 

Начинаем идти по списку и по порядку выполнения программы:

У нас есть несколько параметров вроде количества “потоков”, имен файлов и прочее. Всю эту красоту достать из командной строки поможет встроенный пакет ["flag"](http://golang.org/pkg/flag/). Добавим его в список импорта и, заодно, объявим переменные-параметры:
```go
import (
    "flag"
    "fmt"
)
 
var (
    WORKERS       int             = 2            //кол-во "потоков"
    REPORT_PERIOD int             = 10           //частота отчетов (сек)
    DUP_TO_STOP   int             = 500          //максимум повторов до останова
    HASH_FILE     string          = "hash.bin"   //файл с хешами
    QUOTES_FILE   string          = "quotes.txt" //файл с цитатами
)
``` 

Тип переменной в Go пишется после её названия что может быть слегка непривычно. Также мы сразу инициализируем значения по умолчанию, чтобы было все удобно и в одном месте.

Вещи вроде разбора аргументов принято делать в функции *init()*, так и поступим:
```go
func init() {
    //Задаем правила разбора:
    flag.IntVar(&WORKERS, "w", WORKERS, "количество потоков")
    flag.IntVar(&REPORT_PERIOD, "r", REPORT_PERIOD, "частота отчетов (сек)")
    flag.IntVar(&DUP_TO_STOP, "d", DUP_TO_STOP, "кол-во дубликатов для остановки")
    flag.StringVar(&HASH_FILE, "hf", HASH_FILE, "файл хешей")
    flag.StringVar(&QUOTES_FILE, "qf", QUOTES_FILE, "файл записей")
    //И запускаем разбор аргументов
    flag.Parse() 
}
```
*UPD: Хабраюзер [@Forked](https://habrahabr.ru/users/forked/) в [комментарии](http://habrahabr.ru/post/197598/#comment_6855758) популярно объяснил почему вызывать функцию flag.Parse() в init — плохая привычка. Спасибо ему за это — отныне я буду делать это в main() чего и вам советую, а этот пример останется тут в назидание что "фу так делать!"*

Воспользуемся функциями *IntVar* (для чисел) и *StringVar* (для строк) из пакета *flag* – они читают заданный ключ из аргументов командной строки и передают его в переменную. Если ключ не указан то берется значение по умолчанию. Синтаксис у функций одинаковый:
```go
flag.StringVar( &имя_переменной, ключ ком. строки, значение по умолчанию , описание ключа)
```

Обратите внимание, что мы передаем указатель на переменную (символ &) чтобы функция могла её модифицировать при надобности. Также интересен параметр “описание ключа” – дело в том, что пакет flag автоматически создает нам легенду аргументов доступную по ключу “-h”. Можно прямо сейчас запустить программу и убедиться в этом:
``` bash
C:\Go\src\habratest>habratest.exe -h
Usage of habratest.exe:
  -d=500: кол-во дубликатов для остановки
  -hf="hash.bin": файл хешей
  -qf="quotes.txt": файл записей
  -r=10: частота отчетов (сек)
  -w=2: количество потоков
```

Дальше по плану идет загрузка хешей при старте программы, но к этому я предлагаю вернуться попозже, когда у нас уже будет что загружать. Представим, что у нас пока каждый запуск является первым.

Теперь подумаем про саму программу — она должна читать страницу, разбирать ее, записывать результаты и анализировать прогресс. Да еще и в несколько "потоков" (сразу определимся — потоком я называю thread, а не stream. Ну так, на всякий случай). Ха!

Многозадачность в Go реализуется гоурутинами ([goroutine](http://golang.org/doc/effective_go.html#goroutines)), то есть любую функцию мы можем запустить "в фоне" подставив перед ней ключевое слово "go": она запускается и выполнение программы сразу продолжается, это примерно как запуск команды с & на конце в linux — мы сразу можем делать что-то еще:
```go
//Например если есть ...
func GadgetUmbrella() {
	//...большой и сложный расчет...
}
//...и мы не хотим ждать пока он закончится,  мы просто пишем: 
 go GadgetUmbrella()
 fmt.Println("мы падаем!")
//И сообщение о прискорбном событии будет выведено на экран сразу же, а не после завершения функции GadgetUmbrella()
```
Вообще гоурутины это не потоки в чистом виде, там все гораздо интереснее, но такие вещи уже явно выходят за рамки нашего задания.

Предлагаю вынести в отдельный "поток" функцию которая будет в бесконечном цикле осуществлять загрузку и разбор страницы и отдавать готовую цитату, назовем её "граббер". Пусть себе крутится на заднем фоне в нескольких экземплярах, а мы из основной программы будем в цикле ловить эти цитаты, делать с ними что нужно, и, в случае наступления определенных условий, сворачивать работу. Звучит подозрительно просто, особенно для тех, кто уже имеет опыт многопоточного программирования и уже готов в ужасе кричать про многочисленные нюансы совместного доступа и синхронизации.

Но на деле все действительно просто, потому что еще одной замечательной особенностью Go являются Каналы ([channels](http://golang.org/doc/effective_go.html#channels)). Упрощенно канал легко представить себе как трубу, в которую с одной стороны закидывают значение, а с другой его ловят. Каналы типизированы и требуют инициализации — вкратце работать с ними так:
```go
func send( c chan int) {
   с <- 15    // отправляем число в канал
}

func main() {
	ch := make(chan int) //создаем канал для передачи целых чисел (int)
	go send(ch)
	b:= <-ch   //читаем число из канала
    fmt.Println(b)
}
```
Обратите внимание, что я написал именно *go send(ch)* а не просто *send(сh)*. Дело в том, что по умолчанию передача и получение данных из канала блокируют вызвавшую их подпрограмму до тех пор, пока другой конец не будет готов обработать данные. Это такой замечательный инструмент синхронизации. 
Получается, что если убрать "*go*" то *send()* выполнится в главном потоке и заблокирует его, потому что будет ждать пока кто-то не будет готов забрать наше число 15. Забираем мы его в следующей строке, но на нее уже никогда не будет передано управление. Deadlock, все в печали.
А вот в случае "*go send()*" все пройдет гладко, потому что *send()* заблокируется, но в своем потоке, и будет стоять до тех пор пока мы не произведем чтение в другом — а мы делаем это весьма скоро и обмен данными происходит успешно. 
Так же, если убрать запись в канал в функции *send()*, то мертво встанет уже наоборот главная функция на строчке *b:= <-c*, потому как получать ей будет нечего. 
Каналы это first-class объекты, соответственно их можно создавать, передавать, возвращать и присваивать как будет удобно.

У нас отправлять данные будет "граббер" а получать мы их будем в основном цикле. 

Цитата в коде страницы просто лежит в div с классом "fi_text". Для того чтобы её достать в "граббере" воспользуемся пакетом [goquery](http://github.com/opesun/goquery) — он позволяет разбирать html-страницу и обращаться к её содержимому посредством селекторов а-ля jQuery. Этого пакета нет в стандартной поставке, поэтому его нужно предварительно установить:
```bash
#в консоли выполняем:
go get github.com/opesun/goquery
```
И в раздел импорта в коде добавляем пакеты "*github.com/opesun/goquery*", "*strings*" и "*time*" — последний нам понадобится для задержки, не будем же мы постоянно дергать сервер своими запросами (ну, и так и так будем, но вы меня поняли):
```go
import (
	"flag"
	"fmt"
	"github.com/opesun/goquery"
	"strings"
	"time"
)
```

Ближе к делу — пишем код "граббера":
```go
func grab() <-chan string {  //функция вернет канал, из которого мы будем читать данные типа string
	c := make(chan string) 
	for i := 0; i < WORKERS; i++ { //в цикле создадим нужное нам количество гоурутин - worker'oв
		go func() { 
			for { //в вечном цикле собираем данные
				x, err := goquery.ParseUrl("http://vpustotu.ru/moderation/")
				if err == nil {
					if s := strings.TrimSpace(x.Find(".fi_text").Text()); s != "" {
						c <- s //и отправляем их в канал
					}
				}
				time.Sleep(100 * time.Millisecond)
			}
		}()
	}
	fmt.Println("Запущено потоков: ", WORKERS)
	return c
}
```
Код очень простой и почти не требует комментариев.
Мы используем замыкание, чтобы создать нужное нам количество "гоурутин" выполняющих анонимную функцию, которая постоянно отправляет данные в канал, возвращаемый *grab()*. Такой паттерн называют генератор.
Почему-то *x.Find(".fi_text").Text()* возвращала мне содержимое нужного элемента с пробелами в начале и на конце, поэтому, не долго думая, очищаем её функцией *TrimSpace* из стандартного модуля *strings*.

Итак генератор готов, можно убедиться что он работает модифицировав функцию main():
```go
func main() {
	quote_chan := grab()
	for i := 0; i < 5; i++ { //получаем 5 цитат и закругляемся
		fmt.Println(<-quote_chan, "\n")
	}
}
```
Запускаем и видим что все идет по плану: откровения льются в наш канал широким потоком! 
![Alt text](http://habrastorage.org/storage3/30b/975/a04/30b975a0470e6d17682226428c041cd0.png)
