# Основной цикл

Теперь подумаем над основным циклом, в котором, согласно плану, должны собираться значения. Согласно требованиям и пожеланиям, нам нужен цикл, который: 

* собирает цитаты.
* проверяет их на уникальность сравнивая хеш цитаты с уже имеющимися
* сохраняет цитату и хеш в файлы в случае новой цитаты
* следит за количеством повторов подряд
* отчитывается каждые REPORT_PERIOD секунд
* ну и так как цикл бесконечный, будем ловить ctrl-c чтобы корректно выйти из него по команде пользователя.


Со сбором у нас проблем уже нет, определимся с хешами. 
Для простоты я предлагаю брать md5 от цитаты. Хранить хеши будем в [map](http://golang.org/doc/effective_go.html#maps)(встроенная структура для key-value хранилищ), таким образом их легко и быстро будет искать. Проверить уникальность, подсчитать статистику и повторы — это уже дело техники. Работа с файлами в Go ничем не отличается от других языков, так что тут тоже никаких проблем.

Отчет по времени можно реализовать с помощью [Ticker'a](http://golang.org/pkg/time/#Ticker) из стандартного пакета "*time*". Это простейший таймер, который будет срабатывать через заданный промежуток времени и посылать некое значение в свой канал — достаточно только следить за каналом и при поступлении данных выводить статистику.

А ловить команду на завершение мы будем с помощью пакета "*os/signal*", позволяющего повесить на определенные сигналы нотификатор, посылающий в канал уведомления о событиях.

План готов — но есть один нюанс: у нас получается три разных канала, из которых мы хотим получать данные, однако ранее говорилось, что при ожидании чтения поток блокируется, таким образом мы сможем ждать информации максимум по одному каналу одновременно. 
Но go не зря ест свое процессорное время — еще одним замечательным инструментом является конструкция [select](http://golang.org/ref/spec#Select_statements).

*Select* позволяет ожидать данных из неограниченного количества каналов, блокируя выполнение только в случае прихода очередных данных, на время их обработки. То что нам нужно!

Приступим к коду! Для начала добавим необходимые пакеты в секцию импорта, теперь она будет выглядеть так:
```go
import (
	"flag"
	"fmt"
	"github.com/opesun/goquery"
	"strings"
	"time"
	//Пакеты, которые пригодятся для работы с файлами и сигналами:
	"io"
	"os"
	"os/signal"
	//А вот эти - для высчитывания хешей:
	"crypto/md5"
	"encoding/hex"
)
```
Да, немало всего… Учитывая статическую линковку Go размер исполняемого файла должен получиться впечатляющим!
Но не время грустить, объявим хранилище для хешей:
```go
var (
	...
	used          map[string]bool = make(map[string]bool) //map в котором в качестве ключей будем использовать строки, а для значений - булев тип.
)
```
И, наконец, наша основная функция превращается в:
```go
func main() {
	//Открываем файл с цитатами...
	quotes_file, err := os.OpenFile(QUOTES_FILE, os.O_APPEND|os.O_CREATE, 0666)
	check(err)
	defer quotes_file.Close()
	
	//...и файл с хешами
	hash_file, err := os.OpenFile(HASH_FILE, os.O_APPEND|os.O_CREATE, 0666)
	check(err)
	defer hash_file.Close()

	//Создаем Ticker который будет оповещать нас когда пора отчитываться о работе
	ticker := time.NewTicker(time.Duration(REPORT_PERIOD) * time.Second)
	defer ticker.Stop()

	//Создаем канал, который будет ловить сигнал завершения, и привязываем к нему нотификатор...
	key_chan := make(chan os.Signal, 1)
	signal.Notify(key_chan, os.Interrupt)

	//...и все что нужно для подсчета хешей
	hasher := md5.New()
	
	//Счетчики цитат и дубликатов
	quotes_count, dup_count := 0, 0

	//Все готово, поехали!
	quotes_chan := grab()
	for {
		select {
		case quote := <-quotes_chan: //если "пришла" новая цитата:
			quotes_count++
			//считаем хеш, и конвертируем его в строку:
			hasher.Reset()
			io.WriteString(hasher, quote)
			hash := hasher.Sum(nil)
			hash_string := hex.EncodeToString(hash)
			//проверяем уникальность хеша цитаты
			if !used[hash_string] {
				//все в порядке - заносим хеш в хранилище, и записываем его и цитату в файлы
				used[hash_string] = true
				hash_file.Write(hash)
				quotes_file.WriteString(quote + "\n\n\n")
				dup_count = 0
			} else {
				//получен повтор - пришло время проверить, не пора ли закругляться?
				if dup_count++; dup_count == DUP_TO_STOP {
					fmt.Println("Достигнут предел повторов, завершаю работу. Всего записей: ", len(used))
					return
				}
			}
		case <-key_chan: //если пришла информация от нотификатора сигналов:
			fmt.Println("CTRL-C: Завершаю работу. Всего записей: ", len(used))
			return
		case <-ticker.C: //и, наконец, проверяем не пора ли вывести очередной отчет
			fmt.Printf("Всего %d / Повторов %d (%d записей/сек) \n", len(used), dup_count, quotes_count/REPORT_PERIOD)
			quotes_count = 0
		}
	}
}
```
Код абсолютно прозрачен, остановимся только на открытии файлов:
Функция *check()* не является стандартной — она тут для удобства проверки результатов открытия файла на ошибки. Вот её код, поместим куда-нибудь перед main():
```go
func check(e error) {
	if e != nil {
		panic(e)
	}
}
```
Еще один интересный момент: мы "сразу" вызываем закрытие файла, хотя потом собираемся с ним работать:
```go
defer quotes_file.Close()
...
defer hash_file.Close()
...
//точно также мы и с тикером поступаем:
defer ticker.Stop()
```

Суть в том, что запустив функцию с defer мы откладываем её выполнение: она выполнится только перед тем, как завершится функция из которой был вызов defer (проще говоря — прямо перед return "родителя"). 

Можно уже запускать и радоваться выполнению "ужасно нужной миссии", но осталась еще одна маленькая деталь — нужно написать функцию чтения хешей из файла, на случай если мы захотим запустить программу повторно но не желаем видеть в результирующем файле дубликаты. Вот один из способов, как это можно сделать:
```go
func readHashes() {
	//проверим файл на наличие
	if _, err := os.Stat(HASH_FILE); err != nil {
		if os.IsNotExist(err) {
			fmt.Println("Файл хешей не найден, будет создан новый.")
			return
		}
	}

	fmt.Println("Чтение хешей...")
	hash_file, err := os.OpenFile(HASH_FILE, os.O_RDONLY, 0666)
	check(err)
	defer hash_file.Close()
	//читать будем блоками по 16 байт - как раз один хеш:
	data := make([]byte, 16)
	for {
		n, err := hash_file.Read(data) //n вернет количество прочитанных байт, а err - ошибку, в случае таковой.
		if err != nil {
			if err == io.EOF {
				break
			}
			panic(err)
		}
		if n == 16 {
			used[hex.EncodeToString(data)] = true
		}
	}

	fmt.Println("Завершено. Прочитано хешей: ", len(used))
} 
```
Вот и все, осталось только не забыть поместить вызов readHashes() в начало main()
```go
func main() {
	readHashes()
	...
```
Готово! Боевые запуски:
![Alt text](http://habrastorage.org/storage3/051/83f/06d/05183f06d93ac8816d6efbf530fbb134.png)

Результаты работы:
![Alt text](http://habrastorage.org/storage3/74e/9ed/a11/74e9eda114779583e1d10d000f1733ad.png)

Создание файлов работает, перечитывание хешей при повторном запуске тоже. По команде останавливается, да и сама тоже умеет. Исполняемый файл, конечно, великоват — но и Go с ним.
Наша программа для выгрузки ~~всякой ерундыочень~~ важных данных в ночи готова и делает что мы от нее хотели. 
Конечно, есть еще огромный список улучшений, но для простого выполнения боевой задачи этого кода более чем достаточно!
