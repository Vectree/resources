# Модуль обработки транзакций

Основные требования, предъявляемые к данному сервису:
* Каждая финансовая транзакция должна логгироваться. Заметим, что транзакция обрабатывается и логгируется отдельно;
* Финансовая транзакция, попадая в **журнал транзакций**, после этого не может быть оттуда удалена;
* Внешний сервис, отправивший финансовую транзакцию в систему, блокируется до момента совершения логгирования и изменения кэша счетов данной операции;
* В случае неисправности биллинговой системы должно произойти восстановление системы и пулла необработанных финансовых транзакций. Финансовая транзакция обработана только в том случае, когда изменения по счетам записаны в базу данных;
* В результате обработки, количество изменений по финансовым транзакциям и количество транзакций в базу данных должно быть минимально.

Рассмотрим последоватеьность действий при обработке финансовой транзакции.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b8c0/LRvtDmeYtuU.jpg)

**Внешний сервис**, с помощью некоторого протокола передачи данных (можно использовать любой удобный: Hessian, REST API и т.д), отправляет финансовую транзакцию в **API** разрабатываемой биллинговой ситсемы:

```java
    class Transaction 
    {
        private final int operationType;    // Тип транзакции: дебет или кредит.
        
        private final long src;             // С какого аккаунта перевод.

        private final long dst;             // На какой аккаунт перевод.

        private final BigDecimal amount;    // Сколько переводим.
        
        // setters, getters
    }
```

#### Валидация

Модуль обработки транзакций при получении фин. транзакции выполняет ее валидацию:

* Перевод финансовой транзакции не должен быть меньше нуля для операций типа: дебет, кредит;
* Перевод финансовой транзакции не должен быть равен нулю;
* Источник транзакции не должен совпадать с получателем транзакции;
* Биллинговая система должна быть способна обработать финансовую транзакцию, заданного типа.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b8ef/xB7zG-_gdNE.jpg)

Если валидация прошла успешно, финансовая транзакция отправляется в пулл логгирования, сам **внешний сервис**, ожидающий ответа об успешном выполнении финансовой транзакции, блокируется.

### Пулл логгирования

**Пулл логгирования** хранит в течение заданного времени все пришедшие транзакции. По истечении этого времени из пулла логгирования *консистентно* (в момент получения данных, никто не может добавить транзакции в пулл) забираются все накопившиеся транзакции, с которыми выполняется следующие действия:

![Alt text](https://pp.userapi.com/c840425/v840425205/4b903/sBZ3vYJfkyE.jpg)

* Выполнение объединения операций по одному и тому же счету. Например: операция (дебет: 500) счета сливается с другой операцией (дебет: 300) того же счета. В результате получаем одну операцию (дебет: 800).

* Логгирование финансовых транзакций в базу данных. Финансовая транзакция записывается в базу данных для восстановления в случае ошибок с выполнением операций или отказа сервера. Так же логгирование позволяет реализовать архитектуру, при которой нагрузка на базу данных будет минимальная.

* Изменение кэша (данные хранящиеся в памяти сервиса) счетов. Заметим, что в базе данных дебеты и кредиты на данный момент не изменены.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b8f9/PW8DIyvgvrQ.jpg)

* Разблокировка сервисов, которые отправляли финансовые транзакции. Формально внешний сервис получает ответ об успешном завершении финансовой транзакции. На деле в данный момент изменен только кэш и создана запись в базе логгирования. Изменений по счетам в базе данных нет. За счет такой архитектуры количество одновременных соединений веб-сервера уменьшается.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b923/K1mzZ10tu5g.jpg)

* Передача слитых модификаций в контейнер, отвечающий за накопление модификаций по счетам. По заданному таймеру система выполняет обновление множества счетов в базе за одну транзакцию базы данных. В связи объединения изменений счетов в одну транзакцию, нагрузка на базу данных уменьшается, что позволяет обрабатывать огромный поток финансовых транзакций.

Представленная архитектура уменьшает нагрузку на сервер базы данных и оптимизирует производительность обработки запросов и освобождения соединений веб-сервером.

### Восстановление модуля обработки транзакций 

Наиболее важным требованием к системе является надежность системы и достоверность полученных ответов: если пользователь получил положительный ответ о проведенной операции, то любые проблемы с системой не могут отменить, потерять проведенную операцию.

Как уже было рассмотрено выше, пользователь информируется об успешном завершении финансовой транзакции в момент, когда изменения по транзакции не были выполнены в базе данных.

Рассмотрим ситуацию, когда биллинговая ситсема отказала и не обработала определенный поток транзакций. Пользователи, чьи фин. транзакции были залоггированы, получат ответ об успешной обработке финансовой транзакции. При следующем запуске системы необходимо выполнить восстановление данных транзакций.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b93e/hMbedVJtbTs.jpg)

Восстановление должно происходить в несколько этапов:
1. Все запросы, приходящие в биллинговую систему во время восстановления не принимаются, пока все финансовые транзакции, хранящиеся в журнале логгирования, не будут до конца обработаны. А пользователю будет отправляться ошибка с сообщением о том, что сервис временно недоступен;
2. Формирование списка необработанных транзакций из журнала логгирования;
3. Отправка в «трубу» биллинговой системы и обработка сформированного списка;
4. В случае успешного восстановления, выдать разрешение на обработку финансовых транзакций внешнего пользователя или веб- сервиса.

![Alt text](https://pp.userapi.com/c840425/v840425205/4b947/cOmDYx0qt1I.jpg)

Все операции, выполняемые в биллинговой системе при восстановлении,
проходят все этапы процессинга транзакций: модификацию кэшей, слияние операций и т.д.
