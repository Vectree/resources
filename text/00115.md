## Объекты и конструктор объектов

### Введение

В уроке по основам JavaScript вы должны были изучить [основы использования объектов](https://vectree.ru/text/46/9/0) для хранения и извлечения данных. Давайте немного освежим память.

Существует несколько способов определить объект, но в большинстве случаев лучше использовать синтаксис **объектного литерала**:

```javascript
const myObject = {
  property: "Значение!",
  otherProperty: 77,
  "отвратительное свойство": function() {
    // тут ваш код!
  }
};
```

Существует также 2 способа получения информации из объекта: точечная запись и скобочная запись.

```javascript
// точечная запись
myObject.property; // 'Значение!'

// скобочная запись
myObject["отвратительное свойство"]; // [Function]
```

Какой метод вы используете, будет зависеть от контекста. Точечная запись является более чистой и предпочтительной, но существует множество обстоятельств, когда ее невозможно использовать. Например, код `myObject."отвратительное свойство"` не будет работать, потому что это свойство является строкой с пробелом. Аналогично, вы не можете использовать переменные в точечной нотации:

```javascript
const variable = "property";

myObject.variable; // получим 'undefined', так как идет поиск свойства с именем 'variable'

myObject[variable]; // 'Значение!'
```

Если вы чувствуете, что не все понимаете, самое время повторить раздел [Объекты](https://vectree.ru/text/46/9/0) из курса "Веб-разработка".

### Объекты, как шаблон проектирования

Один из самых простых способов организовать свой код - просто сгруппировать все в объекты. Возьмем для примера игру "крестики-нолики":

```javascript
// пример без объектов
const playerOneName = "tim"; // имя первого игрока
const playerTwoName = "jenn"; // имя второго игрока
const playerOneMarker = "X"; // маркер первого игрока
const playerTwoMarker = "O"; // маркер второго игрока

// пример с объектами
const playerOne = {
  name: "tim",
  marker: "X"
};

const playerTwo = {
  name: "jenn",
  marker: "O"
};
```

На первый взгляд, первый вариант не так уж и плох... и для его написания требуется меньше строк, чем в примере с использованием объектов, но преимущества огромны! Позвольте продемонстрировать:

```javascript
function printName(player) {
  console.log(player.name); // выводим имя игрока
}
```

Это то, что вы НЕ СМОЖЕТЕ сделать с использованием первого примера. Вместо этого, каждый раз, когда вы хотите напечатать имя конкретного игрока, вы должны помнить правильное имя переменной и затем вручную вставлять ее в `console.log`:

```javascript
console.log(playerOneName); // имя первого игрока
console.log(playerTwoName); // имя второго игрока
```

Опять же, это не _так_ плохо... но что, если вы _не не знаете_, какое имя игрока вы хотите напечатать?

```javascript
// winningPlayer - игрок победитель
function gameOver(winningPlayer) {
  console.log("Поздравляем!");
  console.log(winningPlayer.name + " вы победитель!");
}
```

А что, если мы делаем не игру для двух игроков, а что-то более сложное, например, онлайн-магазин с большим ассортиментом товаров? В этом случае использование объектов для отслеживания имени, цены, описания и других свойств является единственным способом. К сожалению, в такой ситуации ручная печать содержимого наших объектов также невозможна. Нам нужен более чистый способ создания наших объектов, который приводит нас к...

### Конструкторы объектов

Если у вас есть определенный тип объекта, который вам нужно продублировать, например, наш игрок в крестики-нолики или товары маназина, лучший способ создать их - использовать конструктор объекта, который выглядит следующим образом:

```javascript
// Конструктор игрока
// name - имя игрока
// marker - тип маркера (крестик / нолик)
function Player(name, marker) {
  this.name = name;
  this.marker = marker;
}
```

Вы можете использовать его, используя ключевое слово `new`:

```javascript
const player = new Player("Стив", "X");
console.log(player.name); // 'Стив'
```

Как и в случае создания с помощью литерала, вы можете добавлять функции к объекту:

```javascript
function Player(name, marker) {
  this.name = name;
  this.marker = marker;
  // Вывести имя
  this.sayName = function() {
    console.log(name);
  };
}

const player1 = new Player("Стив", "X");
const player2 = new Player("Тоже Стив", "O");
player1.sayName(); // выводит 'Стив'
player2.sayName(); // выводит 'Тоже Стив'
```

### Упражнение

Напишите конструктор для создания объектов книг. Мы вернемся к нему в проекте в конце этого урока. Объекты книг должны иметь следующие свойства: имя (или `title`), автор (или `author`), количество страниц книги (или `pages`) и флаг, который сигнализирует, что вы прочитали книгу или нет (`read`).

Поместите в конструктор функцию, которая может сообщать информацию о книге следующим образом

```Javascript
book.info () // 'Хоббит Дж. Р. Р. Толкин, 295 страниц, еще не прочитана'
```

примечание: лучше возвращать (или `return`) значения из функции, а не помещать `console.log()` в нее. В примере выше верните строку `info` и выведите ее после вызова:

```Javascript
console.log(theHobbit.info());
```

### Прототип

Прежде чем мы пойдем дальше, вам нужно кое-что понять об объектах JavaScript. Все объекты в JavaScript имеют `прототип` (или `prototype`). Проще говоря, прототип - это еще один объект, от которого исходный объект _наследуется_, то есть исходный объект, имеет доступ ко всем методам и свойствам своего прототипа.

Эта концепция важна, поэтому вам нужно изучить ее. Убедитесь, что вы осознали все, прежде чем двигаться дальше!

1. [Данная статья](http://javascriptissexy.com/javascript-prototype-in-plain-detailed-language/) представляет собой простое введение и концепцию. Она также рассматривает конструкторы объектов... отличное время для обзора! Когда вы осветите основы, потратьте время на 'Prototype-based inheritance' и 'Prototype chain'. Есть похожая [статья на русском](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

2. Чтобы немного углубиться в цепочки прототипов и наследование, потртатьте время на [несколько замечательных статей от learn.javascript](https://learn.javascript.ru/prototype). Как обычно, практика в конце поможет закрепить все в уме. Не пропустите их! Важное примечание: в этой статье часто встречается `__proto__`, который обычно не рекомендуется для использования. Понимание концепции - это то, что сейчас важно. Мы скоро изучим другие способы установки прототипа.

3. Более глубокая, сложная и не менее крутая [статья о наследовании и цепочках прототипов](http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/). Если вы поняли, что такое прототип, но хотите получить больше информации о работе данного инструмента в JavaScript.

Если вы поняли концепцию прототипа, то следующий кусок не собьет вас с толку!

```javascript
function Student(name) {
  this.name = name;
  this.grade = grade;
}

Student.prototype.sayName = function() {
  console.log(this.name);
};
Student.prototype.goToProm = function() {
  // эм.. идем на выпускной?
};
```

Если вы используете конструкторы для создания своих объектов, лучше всего определить функции в `prototype` этого объекта. Это означает, что один экземпляр каждой функции будет совместно использоваться всеми объектами Student. Если мы объявим функцию непосредственно в конструкторе, как мы делали в предыдущем примере, эта функция будет дублироваться (пересоздаваться) при каждом создании нового объекта Student. В этом примере это не имеет большого значения, но в проекте, который создает тысячи объектов, это действительно может повлиять на производительность.

#### Рекомендуемый метод наследования прототипа

До сих пор вы видели несколько способов заставить объект наследовать прототип от другого объекта. Сейчас рекомендованным способом установки прототипа объекта является `Object.create` ([тут](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create) - документация этого метода). `Object.create` просто возвращает новый объект с указанным прототипом и любыми дополнительными свойствами, которые вы хотите добавить. Для примера выше:

```javascript
function Student() {}

Student.prototype.sayName = function() {
  console.log(this.name);
};

// Создаем конструктор восьмиклассника
function EighthGrader(name) {
  this.name = name;
  this.grade = 8;
}

// Наследуемся от Student
EighthGrader.prototype = Object.create(Student.prototype);

const carl = new EighthGrader("Карл");
carl.sayName(); // выводим "Карл"
carl.grade; // 8
```

Вы, вероятно, уже поняли, что тут происходит. После создания конструктора EighthGrader мы установили его прототип для новых объектов, которые будут копировать свойства `Student.prototype`.

Предупреждение... это не работает:

```javascript
EighthGrader.prototype = Student.prototype;
```

т.к. он буквально установит прототип EighthGrader равным Student.prototype (не копию), что может вызвать проблемы, если вы захотите что-то отредактировать в будущем. Рассмотрим еще один пример:

```javascript
function Student() {}

Student.prototype.sayName = function() {
  console.log(this.name);
};

function EighthGrader(name) {
  this.name = name;
  this.grade = 8;
}

// не делайте так!!!
EighthGrader.prototype = Student.prototype;

function NinthGrader(name) {
  this.name = name;
  this.grade = 9;
}

// Нееееет! Сноооова!
NinthGrader.prototype = Student.prototype;

NinthGrader.prototype.sayName = function() {
  console.log("ХАХАХАХАХАХАХХА");
};

const carl = new EighthGrader("Карл");
carl.sayName(); //О нет! Выводит "ХАХАХАХАХАХАХХА", так как мы изменили sayName функцию!
```

Если бы мы использовали `Object.create` в этом примере, то мы могли бы безопасно отредактировать функцию `NinthGrader.prototype.sayName`, не изменяя функцию для `EighthGrader`.
