## Операторы и выражения

Большинство предложений (логических строк) в программах содержат _выражения_. Простой пример выражения: `2 + 3`. Выражение можно разделить на операторы и операнды.

_Операторы_ – это некий функционал, производящий какие-либо действия, который может быть представлен в виде символов, как например `+`, или специальных зарезервированных слов. Операторы могут производить некоторые действия над данными, и эти данные называются _операндами_. В нашем случае `2` и `3` – это операнды.

### Операторы

Кратко рассмотрим операторы и их применение:

Обратите внимание, вычислить значения выражений, данных в примерах, можно также используя интерпретатор интерактивно. Например, для проверки выражения `2 + 3` воспользуйтесь интерактивной командной строкой интерпретатора Python:

```python
>>> 2 + 3
5
>>> 3 * 5
15
```

#### Операторы и их применение

<table>
    <thead>
        <tr>
            <th>Оператор</th>
            <th>Название</th>
            <th>Объяснение</th>
            <th>Примеры</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>+</code></td>
            <td>Сложение</td>
            <td>Суммирует два объекта</td>
            <td><code>3 + 5</code> даст <code>8</code>; <code>'a' + 'b'</code> даст <code>'ab'</code></td>
        </tr>
        <tr>
            <td><code>-</code></td>
            <td>Вычитание</td>
            <td>Даёт разность двух чисел; если первый операнд отсутствует, он считается равным нулю</td>
            <td><code>-5.2</code> даст отрицательное число, а <code>50 - 24</code> даст <code>26</code>.</td>
        </tr>
        <tr>
            <td><code>*</code></td>
            <td>Умножение</td>
            <td>Даёт произведение двух чисел или возвращает строку, повторённую заданное число раз.</td>
            <td><code>2 * 3</code> даст <code>6</code>. <code>'la' * 3</code> даст <code>'lalala'</code>.</td>
        </tr>
        <tr>
            <td><code>**</code></td>
            <td>Возведение в степень</td>
            <td>Возвращает число <code>х</code>, возведённое в степень <code>y</code></td>
            <td><code>3 ** 4</code> даст <code>81</code> (т.е. <code>3 * 3 * 3 * 3</code>)</td>
        </tr>
        <tr>
            <td><code>/</code></td>
            <td>Деление</td>
            <td>Возвращает частное от деления <code>x</code> на <code>y</code></td>
            <td><code>4 / 3</code> даст <code>1.3333333333333333</code>.</td>
        </tr>
        <tr>
            <td><code>//</code></td>
            <td>Целочисленное деление</td>
            <td>Возвращает неполное частное от деления</td>
            <td><code>4 // 3</code> даст <code>1</code>. <code>-4 // 3</code> даст <code>-2</code>.</td>
        </tr>
        <tr>
            <td><code>%</code></td>
            <td>Деление по модулю</td>
            <td>Возвращает остаток от деления</td>
            <td><code>8 % 3</code> даст <code>2</code>. <code>-25.5 % 2.25</code> даст <code>1.5</code>.</td>
        </tr>
        <tr>
            <td><code><<</code></td>
            <td>Сдвиг влево</td>
            <td>Сдвигает биты числа влево на заданное количество позиций. (Любое число в памяти компьютера представлено в виде битов - или двоичных чисел, т.е. 0 и 1)</td>
            <td><code>2 << 2</code> даст <code>8</code>. В двоичном виде <code>2</code> представляет собой <code>10</code>. Сдвиг влево на <code>2</code> бита даёт <code>1000</code>, что в десятичном виде означает <code>8</code>.</td>
        </tr>
        <tr>
            <td><code>>></code></td>
            <td>Сдвиг вправо</td>
            <td>Сдвигает биты числа вправо на заданное число позиций.</td>
            <td><code>11 >> 1</code> даст <code>5</code>. В двоичном виде <code>11</code> представляется как <code>1011</code>, что будучи смещённым на 1 бит вправо, даёт <code>101</code>, а это, в свою очередь, не что иное как десятичное <code>5</code></td>
        </tr>
        <tr>
            <td><code>&</code></td>
            <td>Побитовое И</td>
            <td>Побитовая операция И над числами</td>
            <td><code>5 & 3</code> даёт <code>1</code>.</td>
        </tr>
        <tr>
            <td><code>|</code></td>
            <td>Побитовое ИЛИ</td>
            <td>Побитовая операция ИЛИ над числами</td>
            <td><code>5 | 3</code> даёт <code>7</code>.</td>
        </tr>
        <tr>
            <td><code>^</code></td>
            <td>Побитовое ИСКЛЮЧИТЕЛЬНО ИЛИ</td>
            <td>Побитовая операция ИСКЛЮЧИТЕЛЬНО ИЛИ</td>
            <td><code>5 ^ 3</code> даёт <code>6</code>.</td>
        </tr>
        <tr>
            <td><code>~</code></td>
            <td>Побитовое НЕ</td>
            <td>Побитовая операция НЕ для числа <code>x</code> соответствует <code>-(x+1)</code></td>
            <td>`~5` даёт `-6`.</td>
        </tr>
        <tr>
            <td><code><</code></td>
            <td>Меньше</td>
            <td>Определяет, верно ли, что <code>x</code> меньше <code>y</code>. Все операторы сравнения возвращают <code>True</code> или <code>False</code>. Обратите внимание на заглавные буквы в этих словах.</td>
            <td><code>5 < 3</code> даст <code>False</code>, а <code>3 < 5</code> даст <code>True</code>. Можно составлять произвольные цепочки сравнений: <code>3 < 5 < 7</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>></code></td>
            <td>Больше</td>
            <td>Определяет, верно ли, что <code>x</code> больше <code>y</code></td>
            <td><code>5 > 3</code> даёт <code>True</code>. Если оба операнда - числа, то перед сравнением они оба преобразуются к одинаковому типу. В противном случае всегда возвращается <code>False</code>.</td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td>Меньше или равно</td>
            <td>Определяет, верно ли, что <code>x</code> меньше или равно <code>y</code></td>
            <td><code>x = 3; y = 6; x &lt;= y</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>&gt;=</code></td>
            <td>Больше или равно</td>
            <td>Определяет, верно ли, что <code>x</code> больше или равно <code>y</code></td>
            <td><code>x = 4; y = 3; x &gt;= 3</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>&lt;=</code></td>
            <td>Меньше или равно</td>
            <td>Определяет, верно ли, что <code>x</code> меньше или равно <code>y</code></td>
            <td><code>x = 3; y = 6; x &lt;= y</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>==</code></td>
            <td>Равно</td>
            <td>Проверяет, одинаковы ли объекты</td>
            <td><code>x = 2; y = 2; x == y</code> даёт <code>True</code>. <code>x = 'str'; y = 'stR'; x == y</code> даёт <code>False</code>. <code>x = 'str'; y = 'str'; x == y</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>!=</code></td>
            <td>Не равно</td>
            <td>Проверяет, верно ли, что объекты не равны</td>
            <td><code>x = 2; y = 3; x != y</code> даёт <code>True</code>.</td>
        </tr>
        <tr>
            <td><code>not</code></td>
            <td>Логическое НЕ</td>
            <td>Если <code>x</code> равно <code>True</code>, оператор вернёт <code>False</code>. Если же <code>x</code> равно <code>False</code>, получим <code>True</code>.</td>
            <td><code>x = True; not x</code> даёт <code>False</code>.</td>
        </tr>
        <tr>
            <td><code>and</code></td>
            <td>Логическое И</td>
            <td><code>x and y</code> даёт <code>False</code>, если <code>x</code> равно <code>False</code> , в противном случае возвращает значение <code>y</code></td>
            <td><code>x = True; not x</code> даёт <code>False</code>.</td>
        </tr>
        <tr>
            <td><code>or</code></td>
            <td>Логическое ИЛИ</td>
            <td>Если <code>x</code> равно <code>True</code>, в результате получим <code>True</code>, в противном случае получим значение <code>y</code></td>
            <td><code>x = True; y = False; x or y</code> даёт <code>True</code>. Здесь также может производиться укороченная оценка выражений.</td>
        </tr>
    </tbody>
</table>

### Краткая запись мат. операций и присваивания

Зачастую результат проведения некой математической операции необходимо присвоить переменной, над которой эта операция производилась. Для этого существуют краткие формы записи выражений:

Вы можете записать:

```python
a = 2; a = a * 3
```

в виде:

```python
a = 2; a *= 3
```

Обратите внимание, что выражения вида `переменная = переменная операция выражение` принимает вид `переменная операция = выражение`.

### Порядок вычисления.

Если имеется выражение вида `2 + 3 * 4`, что производится раньше: сложение или умножение? Школьный курс математики говорит нам, что умножение должно производиться в первую очередь. Это означает, что оператор умножения имеет более высокий приоритет, чем оператор сложения.

Следующая таблица показывает приоритет операторов в Python, начиная с самого низкого (самое слабое связывание) и до самого высокого (самое сильное связывание). Это означает, что в любом выражении Python сперва вычисляет операторы и выражения, расположенные внизу таблицы, а затем операторы выше по таблице.

Эта таблица взята из [Справочника по языку Python](http://docs.python.org/py3k/reference/expressions.html#summary) (англ.) и приводится здесь для полноты описания. На практике лучше использовать скобки для группировки операторов и операндов, чтобы в явном виде указать порядок вычисления выражений. Заодно это облегчит чтение программы. Более подробно см. в разделе **Изменение порядка вычисления** ниже.

#### Приоритет операторов

<table>
    <thead>
        <tr>
            <th>Оператор</th>
            <th>Описание</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>lambda</code></td>
            <td>лямбда-выражение</td>
        </tr>
        <tr>
            <td><code>or</code></td>
            <td>Логическое “ИЛИ”</td>
        </tr>
        <tr>
            <td><code>and</code></td>
            <td>Логическое “И”</td>
        </tr>
        <tr>
            <td><code>not x</code></td>
            <td>Логическое “НЕ”</td>
        </tr>
        <tr>
            <td><code>in</code>, <code>not in</code></td>
            <td>Проверка принадлежности</td>
        </tr>
        <tr>
            <td><code>is</code>, <code>is not</code></td>
            <td>Проверка тождественности</td>
        </tr>
        <tr>
            <td><code><</code>, <code>&lt;=</code>, <code>></code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code></td>
            <td>Сравнения</td>
        </tr>
        <tr>
            <td><code>|</code></td>
            <td>Побитовое “ИЛИ”</td>
        </tr>
        <tr>
            <td><code>^</code></td>
            <td>Побитовое “ИСКЛЮЧИТЕЛЬНО ИЛИ”</td>
        </tr>
        <tr>
            <td><code>&</code></td>
            <td>Побитовое “И”</td>
        </tr>
        <tr>
            <td><code><<</code>, <code>>></code></td>
            <td>Сдвиги</td>
        </tr>
        <tr>
            <td><code>+</code>, <code>-</code></td>
            <td>Сложение и вычитание</td>
        </tr>
        <tr>
            <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
            <td>Умножение, деление, целочисленное деление и остаток от деления</td>
        </tr>
        <tr>
            <td><code>+x</code>, <code>-x</code></td>
            <td>Положительное, отрицательное</td>
        </tr>
        <tr>
            <td><code>~x</code></td>
            <td>Побитовое НЕ</td>
        </tr>
        <tr>
            <td><code>**</code></td>
            <td>Возведение в степень</td>
        </tr>
        <tr>
            <td><code>x.attribute</code></td>
            <td>Ссылка на атрибут</td>
        </tr>
        <tr>
            <td><code>x[индекс]</code></td>
            <td>Обращение по индексу</td>
        </tr>
        <tr>
            <td><code>x[индекс1:индекс2]</code></td>
            <td>Вырезка</td>
        </tr>
        <tr>
            <td><code>f(аргументы ...)</code></td>
            <td>Вызов функции</td>
        </tr>
        <tr>
            <td><code>(выражения, ...)</code></td>
            <td>Связка или кортеж</td>
        </tr>
        <tr>
            <td><code>[выражения, ...]</code></td>
            <td>Список</td>
        </tr>
        <tr>
            <td><code>{ключ:данные, ...}</code></td>
            <td>Словарь</td>
        </tr>
    </tbody>
</table>

Операторы, о которых мы не упомянули, будут объяснены в дальнейших главах.

В этой таблице операторы с _равным приоритетом_ расположены в одной строке. Например, `+` и `-` имеют равный приоритет.

### Изменение порядка вычисления

Для облегчения чтения выражений можно использовать скобки. Например, `2 + (3 * 4)` определённо легче понять, чем `2 + 3 * 4`, которое требует знания приоритета операторов. Как и всё остальное, скобки нужно использовать разумно (не перестарайтесь) и избегать излишних, как в `(2 + (3 * 4))`.

Есть ещё одно преимущество в использовании скобок – они дают возможность изменить порядок вычисления выражений. Например, если сложение необходимо произвести прежде умножения, можно записать нечто вроде (2 + 3) * 4.

### Ассоциативность

Операторы обычно обрабатываются слева направо. Это означает, что операторы с равным приоритетом будут обработаны по порядку от левого до правого. Например, `2 + 3 + 4` обрабатывается как `(2 + 3) + 4`.

### Выражения

Пример (сохраните как `expression.py`):

```python
length = 5
breadth = 2

area = length * breadth
print('Площадь равна', area)
print('Периметр равен', 2 * (length + breadth))
```

Вывод:

```bash
$ python expression.py
Площадь равна 10
Периметр равен 14
```

Как это работает:

Длина и ширина прямоугольника хранятся в переменных `length` и `breadth` соответственно. Мы используем их для вычисления периметра и площади прямоугольника при помощи выражений. Результат выражения `length * breadth` сохраняется в переменной `area`, после чего выводится на экран функцией `print`. Во втором случае мы напрямую подставляем значение выражения `2 * (length + breadth)` в функцию `print`.

Также обратите внимание, как Python “красиво печатает” результат. Несмотря на то, что мы не указали пробела между `'Площадь равна'` и переменной `area`, Python подставляет его за нас, чтобы получить красивый и понятный вывод. Программа же остаётся при этом легкочитаемой (поскольку нам не нужно заботиться о пробелах между строками, которые мы выводим). Это пример того, как Python облегчает жизнь программисту.

### Резюме

Мы увидели, как пользоваться операторами, операндами и выражениями. Это основные строительные блоки любой программы. Далее мы увидим, как это применить на практике.
