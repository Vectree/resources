### Introduction

One of the most unique and useful abilities of JavaScript is its ability to manipulate the DOM. But what _is_ the DOM, and how do we go about changing it? Let's jump right in...

### Learning Outcomes
<details>
  <summary>What is DOM in relation to a webpage?</summary>
  <ul>
    <ul>
      <li>The Document Object Model is a tree-like representation of the contents on a webpage or document.</li>
    </ul>
  </ul>
</details>

<details>
<summary>What's the difference between a "node" and an "element"?</summary>
  <ul>
    <ul>
      <li>A "node" is any object in the DOM hierarchy while an "element" is <b>one specific</b> node.</li>
      <li>"Nodes" can include elements, text content inside an element, code comment blocks not visible to the user, the document itself and even abstract types like "fragments".</li>
    </ul>
  </ul>
</details>
<details>
<summary>How do you target nodes with "selectors"?</summary>
  <ul>
    <ul>
      <li>There are several ways, with CSS style-selectors, to target a node.</li>
      <li><code>&lt;div class="display"&gt;&lt;/div&gt;</code> can be selected as follows:
        <ul>
          <li><code>div</code></li>
          <li><code>div.display</code></li>
          <li><code>.display</code></li>
        </ul>
      </li>
      <li>There are also relational selectors such as <code>firstElementChild</code> or <code>lastElementChild</code>.</li>
      <li>Combined with "Query Selectors", this is how you can target a node using JavaScript</li>
      <ul>i.e. <code>document.querySelector(".display");</code> would select the div above.</ul>
    </ul>
  </ul>
</details>

<details>
  <summary>What are the basic methods for finding/adding/removing and altering DOM nodes?</summary>
  <ul><ul>
    <li>As mentioned above, you can find nodes in the DOM using query selectors.</li>
    <li>To create an element, use <code>document.createElement(tagName[, options])</code></li>
    <ul>
      <li>i.e. <code>const div = document.createElement('div');</code> will create a div element. However, this div has not been added to the webpage yet.</li>
    </ul>
    <li>To append this element, use <code><i>parentNode</i>.appendChild(<i>childNode</i>)</code></li>
    <ul>
      <li>i.e. <code>parentNode.appendChild(div);</code></li>
    </ul>
    <li>To remove this element, <i>parentNode</i>.removeChild(<i>child</i>)</li>
    <li>This will remove <i>child</i> from <i>parentNode</i> on the DOM and returns reference to <i>child</i>.</li>
    <ul>
      <li>i.e. <code>parentNode.removeChild(div);</code></li>
    </ul>
    <li>Once you have a reference to an element, as above, you can alter it in many ways.</li>
    <ul>
      <li><code>div.style.color = 'blue';</code> adds the indicated style rule</li>
      <li><code>div.setAttribute('id', 'theDiv');</code> sets the id attribute of our div to <code>theDiv</code>.</li>
    </ul>
  </ul></ul>
</details>

<details>
  <summary>What is the difference between a "nodelist" and an "array of nodes"?</summary>
  <ul><ul>
    <li>A "nodelist" looks like an array, but it is missing several methods that come with an Array.</li>
    <li>A solution to this problem is to use the spread operator or Array.from() to convert a nodelist into an array.</li>
  </ul></ul>
</details>

<details>
  <summary>How do "events" and "listeners" work? What are three ways to use events in your code?</summary>
  <ul><ul>
    <li>"Events" are how you make your webpage dynamic. They are triggered by "listeners", and can fire when the page loads, when you click your mouse, when you push keys on your keyboard, and many, many more.</li>
    <li>The three primary ways to use events are:</li>
    <ol>
      <li>By attaching scripts to event attributes on elements in the HTML document.</li>
      <ul><li><code>&lt;button onclick="alert(this.tagName)"&gt;Click Me&lt;/button&gt;</code></li></ul>
      <li>By setting the "on_event_" property on the DOM object in your JavaScript.</li>
      <ul><code>
        // the html file<br />
        &lt;button id="btn"&gt;Click Me&lt;/button&gt;<br />
        <br />
        // the JavaScript file<br />
        var btn = document.querySelector(&lsquo;&#35;btn&rsquo;);<br />
        btn.onclick = (e) =&gt; alert(e.target.tagName);<br />
      </code></ul>
      <li>By attaching event listeners to the nodes in your JavaScript.</li>
      <ul><code>
        // the html file<br />
        &lt;button id="btn"&gt;Click Me Too&lt;/button&gt;<br />
        <br />
        // the JavaScript file<br />
        var btn = document.querySelector('#btn');<br />
        btn.addEventListener(&lsquo;click&rsquo;, (e) => {<br />
          &nbsp;&nbsp;alert(e.target.tagName);<br />
        });<br />
      </code></ul>
    </ol>
  </ul></ul>
</details>

<details>
  <summary>How does "bubbling" work?</summary>
  <ul><ul>
    <li>Bubbling is a form of "event propagation."</li>
    <li>It is an efficient method for firing an event on multiple elements -- starting from the innermost element -- and "bubbling" up to outer elements.</li>
  </ul></ul>
</details>

### DOM - объектная модель документа


DOM \(или объектная модель документа\) представляет собой древовидное представление содержимого веб-страницы - дерево «узлов» с различными отношениями в зависимости от того, как они расположены в документе HTML.


~~~ HTML
<div id="container">
  <div class="display"></div>
  <div class="controls"></div>
</div>
~~~


В приведенном выше примере <div class ="display"></div>` является "потомком" `<div id="container"></div>` и родственным элементом для `<div class ="controls"></div>. Думайте об этом как о родственных элементах. <div id="container"></div>` является __parent__, а два других блока - его __children__ на следующем уровне, каждый в своей собственной "ветви".

### Таргетинг на узлы с помощью селекторов

При работе с DOM вы используете «селекторы» для выбора узлов, с которыми вы хотите работать. Вы можете использовать комбинацию селекторов CSS и свойств отношений для выбора нужных узлов. Начнем с селекторов в стиле CSS. В приведенном выше примере вы можете использовать следующие селекторы для ссылки на <div class="display"></div>:

* div.display
* .display
* \#container > .display
* div#container > div.display

Вы также можете использовать реляционные селекторы \(т.е. `firstElementChild` или` lastElementChild` и др. \) Со специальными свойствами, принадлежащими узлам.

~~~ JavaScript
const container = document.querySelector ('#container');
// выбираем #container div (не беспокойтесь о синтаксисе, мы туда доберемся)

console.dir (container.firstElementChild);
// выбираем первого потомка #container => .display

const controls = document.querySelector ('.controls');
// выбираем .controls div

console.dir (controls.previousElementSibling);
// выбираем предыдущего брата => .display
~~~

Таким образом, вы идентифицируете определенный узел на основе его отношений с узлами вокруг него.

### DOM методы

Когда ваш HTML-код анализируется веб-браузером, он преобразуется в DOM, как упоминалось выше. Одно из основных отличий состоит в том, что эти узлы являются объектами, к которым привязаны многие свойства и методы. Эти свойства и методы являются основными инструментами, которые мы будем использовать для управления нашей веб-страницей с помощью JavaScript. Мы начнем с селекторов запросов - тех, которые помогают нацеливать узлы.

#### Селекторы запросов

* _element_.querySelector \(_selector_\) возвращает ссылку на первое совпадение _selector_
* _element_.querySelectorAll \(_selectors_\) возвращает «список узлов», содержащий ссылки на все совпадения _selectors_

\*_Есть несколько других, более конкретных запросов, которые предлагают потенциальные \(предельные\) преимущества в производительности, но мы не будем их рассматривать сейчас_

Важно отметить, что при использовании querySelectorAll возвращаемое значение **не** массив. Он выглядит как массив и в некоторой степени действует как массив, но на самом деле это «список узлов». Большим отличием является то, что в списках узлов отсутствуют несколько методов массива. Одним из решений, если возникают проблемы, является преобразование списка узлов в массив. Вы можете сделать это с помощью Array.from(\) или [оператора распространения.](Https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)

#### Создание элемента

* document.createElement \(tagName \[,options \] \) создает новый элемент типа tagName. `[options]` в этом случае означает, что вы можете добавить некоторые необязательные параметры в функцию. Не беспокойтесь об этом на данный момент.

~~~ JavaScript
const div = document.createElement('div');
~~~

Эта функция НЕ помещает ваш новый элемент в DOM - она просто создает его в памяти. Это сделано для того, чтобы вы могли манипулировать элементом (добавляя стили, классы, идентификаторы, текст и т. д.) перед размещением его на странице. Вы можете поместить элемент в DOM одним из следующих способов.

#### Добавить элементы

* _parentNode_.appendChild \(_childNode_\) добавляет _childNode_ как последний дочерний элемент _parentNode_
* _parentNode_.insertBefore \(_newNode_, _referenceNode_\) вставляет _newNode_ в _parentNode_ перед _referenceNode_

#### Удалить элементы

* _parentNode_.removeChild \(_child_) удаляет _child_ из _parentNode_ в DOM и возвращает ссылку на _child_

#### Изменение элементов

Если у вас есть ссылка на элемент, вы можете использовать эту ссылку для изменения собственных свойств элемента. Это позволяет вам делать много полезных изменений, таких как добавление / удаление и изменение атрибутов, изменение классов, добавление информации о встроенном стиле и многое другое.

~~~ JavaScript
const div = document.createElement('div');
// создаем новый div, указанный в переменной 'div'
~~~

#### Добавление встроенного стиля

~~~ JavaScript
div.style.color = 'blue';
// добавляет указанное правило стиля

div.style.cssText = 'color: blue; background: white';
// добавляет несколько правил стиля

div.setAttribute ('style', 'color: blue; background: white');
// добавляет несколько правил стиля
~~~

См. [Раздел о правилах стиля CSS в DOM Enlightenment](http://domenlightenment.com/#6.2) для получения дополнительной информации о встроенных стилях.

Обычно правила стиля такие же, как в CSS, за исключением того, что переносимые правила изменены на camelCase. То есть "background-color" становится "backgroundColor".

#### Редактирование атрибутов

~~~ JavaScript
div.setAttribute('id', 'theDiv');
// если идентификатор существует, обновить его до 'theDiv', иначе создать идентификатор
// со значением "theDiv"

div.getAttribute('ID');
// возвращает значение указанного атрибута, в этом случае
// "theDiv"

div.removeAttribute('ID');
// удаляет указанный атрибут
~~~

См. Раздел MDNs в [Атрибутах HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes) для получения дополнительной информации о доступных атрибутах.

#### Работа с классами

~~~ JavaScript
div.classList.add('new');
// добавляет класс "new" в ваш новый div

div.classList.remove('new');
// удаляем «new» класс из div

div.classList.toggle('active');
// если у div нет класса «active», добавьте его, или если
// он делает, затем удаляет его
~~~

Часто стандартно \(и более чисто) переключать стиль CSS, а не добавлять и удалять встроенный CSS.

#### Добавление текстового контента

~~~ JavaScript
div.textContent = 'Привет, мир!'
// создаем текстовый узел, содержащий «Привет, мир!» а также
// вставляет его в div
~~~

#### Добавление содержимого HTML

~~~ JavaScript
div.innerHTML = '<span> Hello World! </span>';
// рендерим HTML внутри div
~~~

Обратите внимание, что textContent предпочтительнее для добавления текста, и innerHTML следует использовать с осторожностью, поскольку при неправильном использовании он может создавать угрозы безопасности.

Давайте уделим минуту тому, чтобы рассмотреть то, что мы рассмотрели, и дать вам возможность попрактиковаться в этом, прежде чем двигаться дальше. Посмотрите этот пример создания и добавления элемента DOM на веб-страницу.

~~~html
// ваш html:
<body>
  <h1>
    Заголовок вашей страницы
  </h1>
  <div id="container"></div>
</body>
~~~

~~~javascript
// ваш javascript-файл
const container = document.querySelector('#container');

const content = document.createElement('div');
content.classList.add('content');
content.textContent = 'This is the glorious text-content!';

container.appendChild(content);
~~~

В файле JavaScript сначала мы получаем ссылку на div `container`, который уже существует в нашем HTML. Затем мы создаем новый div и сохраняем его в переменной `content`. Мы добавляем класс и некоторый текст в div `content` и, наконец, добавляем этот div в` container`. В целом, это простой процесс. После запуска кода JavaScript наше дерево DOM будет выглядеть так:

~~~html
// The DOM
<body>
  <h1>
    Заголовок вашей страницы
  </h1>
  <div id="container">
  	<div class="content">
      This is the glorious text-content!
    </div>
  </div>
</body>
~~~

Помните, что JavaScript не изменяет ваш HTML, но JavaScript изменяет то, что отображает браузер.

> **Важное замечание: **
>Ваш JavaScript, по большей части, запускается всякий раз, когда запускается файл JS или когда тег HTML встречается в HTML. Если вы включаете JavaScript в начало вашего файла, многие из этих методов манипулирования DOM не будут работать, потому что код JS выполняется *до* создания узлов в DOM. Самый простой способ исправить это - включить JavaScript в конец HTML-файла, чтобы он запускался после анализа и создания DOM-узлов.

### Упражнение

Скопируйте приведенный выше пример в файлы на вашем компьютере. Чтобы это работало, вам нужно предоставить оставшуюся часть HTML-скелета и либо связать свой файл javascript, либо поместить javascript в тег script на странице. Убедитесь, что все работает, прежде чем двигаться дальше!

Добавьте следующие элементы в контейнер, используя ТОЛЬКО javascript - не добавляйте HTML или CSS-код.

1. `<p>` с красным текстом "Эй, я красный!"
2. `<h3>` с синим текстом, который говорит: «Я синий h3!»
3. `<div>` с черной рамкой и розовым цветом фона со следующими элементами внутри:
   1. другой `<h1>`, который говорит "я в div"
   2. `<p>` с надписью "Я СЛИШКОМ!"
   3. Подсказка: после создания div с помощью createElement добавьте к нему `<h1>` и `<p>` перед добавлением его в контейнер.

### События

Теперь, когда мы имеем дело с манипулированием DOM с помощью JavaScript, следующим шагом будет изучение того, как сделать это динамически или по требованию! 
События - это то, как вы делаете это волшебство на ваших страницах. События - это действия, которые происходят на вашей веб-странице, такие как щелчки мышью или нажатия клавиш, и с помощью JavaScript мы можем заставить нашу веб-страницу слушать и реагировать на эти события.

Есть три основных способа сделать это: вы можете прикрепить атрибуты функций непосредственно к вашим HTML-элементам, вы можете установить свойство _on_event_ для объекта DOM в вашем JavaScript или вы можете присоединить слушатели событий к узлам в вашем JavaScript. Слушатели событий, безусловно, являются предпочтительным методом, но вы будете регулярно видеть других в использовании, поэтому мы собираемся охватить все три.

Мы собираемся создать 3 кнопки, которые все нажимают «КНОПКУ» при нажатии. Попробуйте их все, используя собственный HTML-файл или что-то вроде [CodePen](https://codepen.io/).

#### метод 1

~~~ HTML
<button onclick="alert('Hello World')">Нажми на меня</ button>
~~~

Это решение не идеально, потому что мы загромождаем наш HTML с помощью JavaScript. Кроме того, мы можем иметь только 1 событие «onclick» на элемент.

#### метод 2

~~~ HTML
// HTML-файл
<button id ="btn">Нажмите на меня</ button>
~~~

~~~ JavaScript
// файл JavaScript
var btn = document.querySelector('# btn');
btn.onclick = () => alert ("Hello World");
~~~

#### \ (нужно познакомиться с стрелочными функциями? [LINK](http://javascript.info/function-expressions-arrows#arrow-functions)\)

Это немного лучше. Мы переместили JS из HTML в файл JS, но у нас все еще есть проблема, что элемент DOM может иметь только 1 свойство "onclick".

#### метод 3

~~~ HTML
// HTML-файл
<button id="btn">Нажми и меня</button>
~~~

~~~ JavaScript
// файл JavaScript
var btn = document.querySelector('# btn');
btn.addEventListener('click', () => {
  alert («Привет, мир»);
});
~~~

Теперь мы поддерживаем не только разделение кода, но и также разрешаем множественные прослушивания событий, если это необходимо. Метод 3 гораздо более гибкий и мощный, хотя его немного сложнее настроить.

Обратите внимание, что все 3 из этих методов могут использоваться с именованными функциями следующим образом:

~~~ HTML
// HTML-файл
// МЕТОД 1
<button onclick = "alertFunction()">НАЖМИТЕ</button>
~~~

~~~ Javascript
function alertFunction () {
  alert(«ДА! ТЫ ЭТО СДЕЛАЛ!»);
}

// МЕТОД 2
btn.onclick=alertFunction

// МЕТОД 3
btn.addEventListener('click', alertFunction);
~~~

Использование именованных функций может значительно очистить ваш код, и это действительно хорошая идея, если функция - это то, что вы захотите использовать в разных местах.

Используя все три метода, мы можем получить дополнительную информацию о событии, передав параметр в функцию, которую мы вызываем. Попробуйте это на своей машине:

~~~ Javascript
btn.addEventListener('click', function (e) {
  console.log (е)
})
~~~

`E` в этой функции является объектом, который ссылается на само __event__. Внутри этого объекта у вас есть доступ ко многим полезным свойствам и функциям, таким как, какая кнопка мыши или клавиша была нажата, или информация о __target__ события - узле DOM, по которому щелкнули.

Попробуйте это:

~~~ Javascript
btn.addEventListener('click', function (e) {
  console.log (e.target)
})
~~~

а теперь вот это:

~~~ Javascript
btn.addEventListener('click', function (e) {
  e.target.style.background = 'blue'
})
~~~

довольно круто, а?

#### Прикрепление слушателей к группам узлов

Если вы присоединяете много похожих слушателей событий ко многим элементам, вам может потребоваться много кода.
Есть несколько способов сделать это более эффективно. Выше мы узнали, что можем получить список узлов всех элементов, соответствующих конкретному селектору, с помощью `querySelectorAll('selector')`. Чтобы добавить слушателя к каждому из них, нам просто нужно перебрать весь список следующим образом:

~~~ HTML
<div id = "container">
    <button id = "1"> Нажмите меня </button>
    <button id = "2"> Нажмите меня </button>
    <button id = "3"> Нажмите меня </button>
</ DIV>
~~~

~~~ JavaScript
// кнопки - это список узлов. Это выглядит и действует как массив.
const buttons = document.querySelectorAll('button');

// мы используем метод .forEach для итерации каждой кнопки
buttons.forEach((button) => {
  // и для каждого мы добавляем слушателя 'click'
  button.addEventListener('click', (e) => {
    alert(button.id);
  });
});
~~~

Это всего лишь вершина айсберга, когда дело доходит до манипулирования DOM и обработки событий, но этого достаточно, чтобы вы начали некоторые упражнения. До сих пор в наших примерах мы использовали исключительно событие «click», но для вас доступно еще _множество других полезных вещей_.

Некоторые полезные события включают в себя:

- click
- dblclick
- keypress
- keydown
- keyup

Вы можете найти более полный список с объяснениями каждого события на [этой странице](https://www.w3schools.com/jsref/dom_obj_event.asp).

### Практика

Управление веб-страницами является основным преимуществом языка JavaScript! Эти методы - вещи, с которыми вы, вероятно, будете связываться с _каждый день_ как разработчик  интерфейса, поэтому давайте потренируемся!

1. Выполните первое упражнение в программе JavaScript30 от Wes Bos, клонировав репозиторий по адресу [https://github.com/wesbos/JavaScript30](https://github.com/wesbos/JavaScript30). Посмотрите [Видеоурок](https://www.youtube.com/watch?v=VuN8qwZoego) для получения инструкций по проекту.
2. Вернитесь к своей игре «Rock Paper Scissors» из предыдущего урока и дайте ему простой пользовательский интерфейс, чтобы игрок мог играть в игру, нажимая кнопки, а не вводя свой ответ в командной строке.
   1. Скопируйте исходный код в новый файл, чтобы не потерять его.
   2. Пока удалите логику, которая запускает ровно пять раундов.
   3. Создайте три кнопки, по одной для каждого выбора. Добавьте прослушиватель событий к кнопкам, вызывающим вашу функцию playRound с правильным значением playerSelection. каждый раз, когда нажимается кнопка. (вы можете использовать console.logs для этого шага)
    4. Добавьте `div` для отображения результатов и измените все ваши`console.log` на методы DOM.
    5. Покажите текущий счет и объявите победителя игры, как только один игрок наберет 5 очков.
    6. Вам, вероятно, придется реорганизовать (переработать / переписать) свой исходный код, чтобы он работал с нашими новыми дополнениями. Это нормально! Переработка старого кода - важная часть жизни программиста.
    7. Не забудьте вернуться и добавить свою новую версию в оригинальный проект Rock Paper Scissors Project!

### Дополнительные ресурсы
* [Eloquent JS - DOM](http://eloquentjavascript.net/13_dom.html)
* [Eloquent JS - Handling Events](http://eloquentjavascript.net/14_event.html)
* [DOM Enlightenment](http://domenlightenment.com/)
* [JavaScript30](https://JavaScript30.com)
* [An introduction to DOM](https://leila-alderman.github.io/javascript/2018/12/05/Intro-to-the-Document-Object-Model.html)
* Если вы готовы начать знакомство с JQuery, то вам поможет [этот сайт](https://plainjs.com/javascript/)
* Этот урок на [W3Schools](https://www.w3schools.com/js/js_htmldom.asp) просто и понятно рассказывает о DOM